<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 1. 表示私有属性/方法时，可在属性/方法前面添加 # 或者 static
    class Fun {
      constructor(name) {
        this.name = name
        // this.handle = this.handle.bind(this)
      }
      handle() {
        console.log('this:', this)
      }
    }

    let temp = new Fun('aaa')
    temp.handle()
    const { handle } = temp
    handle()   // 如果不bind this， 打印的this是undifined

    // 2. new.target  如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。
    function Fun1(name) {
      if(new.target !== undefined) {
        this.name = name
      } else {
        throw new Error('请使用new构造实例')
      }
    }
  const fun = new Fun1('fun')
  const fun1 = Fun1.call(fun, 'fun1')

	// 3. 类方法中this的指向
  </script>
</body>
</html>